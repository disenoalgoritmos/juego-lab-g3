S:servidor
C:cliente
G:Game

addr:[ip,puerto]

####################
##### MENSANGES ####
####################

El cliente pide al servidor crear un nuevo juego
C---->S {type:NEW_GAME,ID_GAME:nombre juego}
    S---->C{type:RESPONSE,MESSAGE:[ip,puerto]}     #En caso de exito el servidor crea una instancia de Game y devuelve al cliente la direccion de ese game
        #Aunque creo que no seria necesario devolver la addr porque de todos modos tendria que hacer un JOIN_GAME(tanto al servidor principal como a game)
    
    S---->C{type:RESPONSE,MESSAGE:ERROR}    #En caso de fallo

El cliente pide al servidor una lista de games disponibles para unirse
C---->S {type:SEARCH_GAME}
    S---->C {type:Response, MESSAGE: 'diccionario con clave el id del game y como valor el par ip/puerto'}    #games puede ser vacio si no encuentra nada

Un cliente pide unirse a una partida con cierto id game
C---->S {type:JOIN_GAME,id_game:id}
    S---->C {type:RESPONSE, MESSAGE: 'addr del game que se esta intentando unir'}  #El servidor devuelve la direccion de game al que se va a unir
        C---->G {type:JOIN_GAME}    #Es necesaria otra llamada join al servidor GAME porque el servidor GAME no conoce a los jugadores
            G---->C {Type:GAME_OK,Turn:turno}   #En el diagrama devuelve id_game y state, pero lo veo inecesario.Turno puede ser 0 o 1 segun el turno del jugador
                C---->G {Type:Response,MESSAGE:OK}  #Aqui Game deberia esperar a recibir los ok de ambos jugadores
                #Aqui el jugador con el turno 0 enviaria un mensage MOVE y empezaria el bucle
                G---->S {type:RESULT, result:id_user/empate/anulada}
            G---->C {type:RESPONSE,MESSAGE:error}   #El servidor GAME a rechazado el join por alguna razon
    S----C {Type:RESPONSE,MESSAGE:ERROR}    #El servidor principal a rechazado el join por alguna razon

